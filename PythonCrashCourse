

###Calculating Average file size

total = 2048 + 4357 + 97658 + 125 + 8
files = 5
average = total / files
print("The average size is " + str(average))











###Listintg sum of square roots

def square(n):
    return n*n

def sum_squares(x):
    sum = 0
    for n in range(1,x):
        sum += square(n)
    return sum

print(sum_squares(10))


OR


def square(n):
    return n*n

def sum_squares(x):
    sum = 0
    for n in range(x):
        sum += square(n)
    return sum

print(sum_squares(10)) # Should be 285














###restaurant share calculator
bill = 47.28
tip = bill * (15/100)
total = bill + tip
share = total/2
print("Each person needs to pay: " + str(share))










###Convert miles to Km

def convert_distance(miles):
	km = miles * 1.6 # approximately 1.6 km in 1 mile
	return km
my_trip_miles = convert_distance(55)

# 2) Convert my_trip_miles to kilometers by calling the function above
my_trip_km = my_trip_miles

# 3) Fill in the blank to print the result of the conversion
print("The distance in kilometers is " + str(my_trip_km))

# 4) Calculate the round-trip in kilometers by doubling the result,
# and fill in the blank to print the result
print("The round-trip in kilometers is " + str(my_trip_miles* 2))









### Color Translator to Hexvalue
def color_translator(color):
	if color == "red":
		hex_color = "#ff0000"
	elif color == "green":
		hex_color = "#00ff00"
	elif color == "blue":
		hex_color = "#0000ff"
	else:
		hex_color = "unknown"
	return hex_color

print(color_translator("blue")) # Should be #0000ff
print(color_translator("yellow")) # Should be unknown
print(color_translator("red")) # Should be #ff0000
print(color_translator("black")) # Should be unknown
print(color_translator("green")) # Should be #00ff00
print(color_translator("")) # Should be unknown










### Name Organizer
def format_name(first_name, last_name):
	# code goes here
  if first_name != '' and last_name !='':
     return ("Name: " + last_name + ", " + first_name)
  elif first_name != ' ' or last_name !=' ':
     return ("Name: " + first_name + last_name)
  else:
     return ''


print(format_name("Ernest", "Hemingway"))
# Should return the string "Name: Hemingway, Ernest"

print(format_name("", "Madonna"))
# Should return the string "Name: Madonna"

print(format_name("Voltaire", ""))
# Should return the string "Name: Voltaire"

print(format_name("", ""))
# Should return an empty string










### Choose the longets word (first in list if same)
def longest_word(word1, word2, word3):
	if len(word1) >= len(word2) and len(word1) >= len(word3):
		word = word1
	elif len(word2) >= len(word1) and len(word2) >= len(word3):
		word = word2
	else:
		word = word3
	return(word)

print(longest_word("chair", "couch", "table"))
print(longest_word("bed", "bath", "beyond"))
print(longest_word("laptop", "notebook", "desktop"))









###########################################


Conditionals Cheat Sheet

In earlier videos, we took a look at some of the built-in Python operators
that allow us to compare values, and some logical operators we can use to
combine values. We also learned how to use operators in if-else-elif blocks.

It’s a lot to learn but, with practice, it gets easier to remember it all.
In the meantime, this handy cheat sheet gives you all the information you
need at a glance.

Comparison operators

    a == b: a is equal to b
    a != b: a is different than b
    a < b: a is smaller than b
    a <= b: a is smaller or equal to b
    a > b: a is bigger than b
    a >= b: a is bigger or equal to b

Logical operators

    a and b: True if both a and b are True. False otherwise.
    a or b: True if either a or b or both are True. False if both are False.
    not a: True if a is False, False if a is True.





#########################################################









### dividing numerator % denominator
def fractional_part(numerator, denominator):
	# Operate with numerator and denominator to
# keep just the fractional part of the quotient
	if denominator >0:
		  return (numerator%denominator)/denominator

	return 0

print(fractional_part(5, 5)) # Should be 0
print(fractional_part(5, 4)) # Should be 0.25
print(fractional_part(5, 3)) # Should be 0.66...
print(fractional_part(5, 2)) # Should be 0.5
print(fractional_part(5, 0)) # Should be 0
print(fractional_part(0, 5)) # Should be 0












###Print out numbers 1 through 7

number = 1
while number in range(1, 8):
	print(number, end=" ")
	number +=1












###Print one line per letter
def show_letters(word):
	for letter in word:
		print(letter)

show_letters("Hello")
# Should print one line per letter












### Count Digits
def digits(n):
	return len(str(n))


print(digits(25))   # Should print 2
print(digits(144))  # Should print 3
print(digits(1000)) # Should print 4
print(digits(0))    # Should print 1











#####Multiplication Table Print out

def multiplication_table(start, stop):
	for x in range(start,stop+1):
		for y in range(start,stop+1):
			print(str(x*y), end=" ")
		print()

multiplication_table(1, 3)
# Should print the multiplication table shown above











###counter function

def counter(start, stop):
	x = start
	if start > stop:
		return_string = "Counting down: "
		while x >= stop:
			return_string += str(x)
			x-=1
			if x >= stop:
				return_string += ","
			___
	else:
		return_string = "Counting up: "
		while x <= stop:
			return_string += str(x)
			x+=1
			if x <=stop:
				return_string += ","
			___
	return return_string

print(counter(1, 10)) # Should be "Counting up: 1,2,3,4,5,6,7,8,9,10"
print(counter(2, 1)) # Should be "Counting down: 2,1"
print(counter(5, 5)) # Should be "Counting up: 5"















### Print only even numbers

def even_numbers(maximum):
	return_string = ""
	for x in range(2, maximum+1, 2):
		return_string += str(x) + " "
	return return_string.strip()

print(even_numbers(6))  # Should be 2 4 6
print(even_numbers(10)) # Should be 2 4 6 8 10
print(even_numbers(1))  # No numbers displayed
print(even_numbers(3))  # Should be 2
print(even_numbers(0))  # No numbers displayed













###Print Prime Factors

def print_prime_factors(number):
  # Start with two, which is the first prime
  factor = 2
  # Keep going until the factor is larger than the number
  while factor <= number:
    # Check if factor is a divisor of number
    if number % factor == 0:
      # If it is, print it and divide the original number
      print(factor)
      number = number / factor
    else:
      # If it's not, increment the factor by one
      factor +=1
  return "Done"

print_prime_factors(100)
# Should print 2,2,5,5














###finding if number is power of 2( watching out for infinte loops)

def is_power_of_two(n):
  # Check if the number can be divided by two without a remainder
  while n % 2 == 0 and n != 0:
    n = n / 2
  # If after dividing by two the number is 1, it's a power of two
  if n == 1:
    return True
  return False


print(is_power_of_two(0)) # Should be False
print(is_power_of_two(1)) # Should be True
print(is_power_of_two(8)) # Should be True
print(is_power_of_two(9)) # Should be False















#### Sum of all the divisors of a number

def sum_divisors(n):
  i = 1
  sum = 0
  # Return the sum of all divisors of n, not including n
  while i<n:
    if n% i==0:
      sum +=i
      i +=1
    else:
      i+=1

  return sum

print(sum_divisors(0))
# 0
print(sum_divisors(3)) # Should sum of 1
# 1
print(sum_divisors(36)) # Should sum of 1+2+3+4+6+9+12+18
# 55
print(sum_divisors(102)) # Should be sum of 2+3+6+17+34+51
# 114










############print the multiplication tables of a number

def multiplication_table(number):
	# Initialize the starting point of the multiplication table
	multiplier = 1
	# Only want to loop through 5
	while multiplier <= 5:
		result = multiplier * number
		# What is the additional condition to exit out of the loop?
		if result > 25 :
			break
		print(str(number) + "x" + str(multiplier) + "=" + str(result))
		# Increment the variable for the loop
		multiplier += 1

multiplication_table(3)
# Should print: 3x1=3 3x2=6 3x3=9 3x4=12 3x5=15

multiplication_table(5)
# Should print: 5x1=5 5x2=10 5x3=15 5x4=20 5x5=25

multiplication_table(8)
# Should print: 8x1=8 8x2=16 8x3=24







##########Sum all the squares of a number

def square(n):
    return n*n

def sum_squares(x):
    sum = 0
    for n in range(x):
        sum += square(n)
    return sum

print(sum_squares(10)) # Should be 285


















########## For Looooop  Printing Friend names

friends = ["Fernando", "Pedro", "Juan", "Miguel"]
for friend in friends:
	print("Hi " + friend "!")
















########## iterate over a list of numbers to calculate the total sum and average

values = [69, 78, 53, 69]
sum = 0
for value in values:
	sum += value
	length += 1

print("Total sum: " + str(sum) " - Average: " + str(sum/lenth))

















################################################################

##################################################################



Not sure whether to use a for loop or a while loop?
Remember that

 A while loop is great for performing an action over and over until a condition has changed.

 A for loop works well when you want to iterate over a sequence of elements.



##################################################################

#######################################################################





More FOR loop examples






###########

product  = 1
for n in range(1, 10):
	product *= n

print(product)








##########FACTORIAL product of an integer and all subsequent integers

def factorial(n):
    result = 1
    for i in range(n):
        i +=1
        result *=i
    return result

print(factorial(4)) # should return 24
print(factorial(5)) # should return 120




or


def factorial(n):
    result = 1
    for x in range(1, n):
        x += 1
        result *= x
    return result

for n in range(0, 9):
    print(n, factorial(n+1))




###########################################################################
###########################################################################

THE RANGE() FUNCTION:



It can recieve one, two , or three parameters

range(1, 2, 3)

If it recieves one parameter
it will CREATE A SEQUENCE, one by one,
from ZERO until ONE LESS than the parameter recieved

If it recieves two parameters
it will CREATE A SEQUENCE, one by one
FROM the FIRST paramtetr
until ONE LESS than the SECOND parameter

If it recieves three parameters
it will CREATE A SEQUENCE
Starting from the FIRST number
and moving towards the SECOND number
but this time the JUMPS will be the size of the THIRD number


##########################################################################
##########################################################################














########## Temperature Converter, F to Calculate

def con_celsius(x):
	return (x-32)*5/9

for x in range(0, 101, 10)
	print(x, con_celsius(x))








++++++NESTED LOOPS++++++++++++

also: attention to new parameter







########## Prints each tile in a set

Domino loop -----------


for left in range(7):
	for right in range(left, 7):
		## in the print function you see the end parameter
		print("[" + str(left) + "|" + str(right) + "]", end=" ")
	print()


OUTPUT:

[0|0] [0|1] [0|2] [0|3] [0|4] [0|5] [0|6]
[1|1] [1|2] [1|3] [1|4] [1|5] [1|6]
[2|2] [2|3] [2|4] [2|5] [2|6]
[3|3] [3|4] [3|5] [3|6]
[4|4] [4|5] [4|6]
[5|5] [5|6]
[6|6]















########## Team VS Loop


teams= [ 'Cabrones', 'Mamados', 'Los Tequerisi', 'Chivas', 'Cholos', 'America']
for home_team in teams:
	for away_team in teams:
		if home_team != away_team:
			print(home_team + " VS " + away_team)













######### Greet Friend Loop

def greet_freinds(friend):
	for friend in friends:
		print("Hi " + friend)









###################################
#################################



recursive function


def factorial(n):
	if n < 2:
		return 1
	return n * factorial(n-1)
	print( "Returning " + str(result) + " for factorial of " + str(n))
	return result





###############################################
#############################################

STRINGGGGSSSS

LALALALALALA

message = "Fernando"

print(("L" + message[4]) x 5 )

##########################################
#############################################




message = " A kong string with a silly typo"


###### RETURNS A TYPE ERROR  ( STRINGS ARE IMMUTABLE )
message[2] = "l"


###### SO SOLUTION

new_message =  message[:2] + "l" + message[3:]
print(new_message)




###############################################
#############################################

*****NEW METHOD ( Function applies to a variable):      .index

#############################################
###############################################


pets = "Cats & Dogs"

pets.index("&")
5

pets.index("C")
0

pets.index("Dog")
7

#returns just the first position that matches
pets.index("s")
3


###############################################
#############################################

Know if if a substring is present

using the keyword  " in "


"Dragons" in pets

returns FALSE

"Cats" in pets

returns TRUE , as it is found in our original variable pets = "Cats & Dogs"



here, " in " is used as a conditional that will return either TRUE or FALSE

#############################################
###############################################

 Imagine that your company has recently moved to using a new domain,
 but a lot of the company email addresses are still using the old one.
 You want to write a program that replaces this old domain with the
 new one in any outdated email addresses. The function to replace
 the domain would look like this.



 def replace_domain(email, old_domain, new_domain):
	if "@" + old_domain in email:
			index = email.index("@" + old_domain)
			new_email = email [:index] + "@" + new_domain
			return new_email
	return email






###############################################
#############################################

Prints the position of the given substring using the .index method

#############################################
###############################################

word = "supercalifragilisticexpialidocious"
new_word = word.index("x")

print(new_word)




###############################################
#############################################
###############################################
#############################################


STRING METHODS FOR TRANSFORMING

So far, we've seen ways you can access portions of strings using
the indexing technique, create new strings by slicing and
concatenating, find characters and strings using the index method,
and even test if one string contains another. On top of all this
string processing power, the string class provides a bunch of
other methods for working with text.


#############################################
###############################################
#############################################
###############################################


Some string methods let you perform
transformations or formatting on the
string text, like upper, and its opposite,
lower

##############################################################################################
"Mountains" .upper()
'MOUNTAINS'
##############################################################################################
"Mountains" .lower()
'mountains'


ex.

answer = 'YES'
if answer.lower() == "yes":
	print ("User said yes")



returns User said yes



##############################################################################################

another useful method strip

" yes ".strip()
'yes'

" yes ".lstrip()
'yes '

" yes ".rstrip()
' yes'



##############################################################################################

The method endswith returns whether the string ends with a certain substring.


"The number of times e occurs in this string is not 3 it is 4".count("e")

returns  4



#############################################
###############################################


MANY OTHERS

.endswith
.isnumeric
.split

list too long
#############################################
###############################################
###############################################
#############################################
String Reference Cheat Sheet
String Reference Cheat Sheet
In Python, there are a lot of things you can do with strings. In this cheat sheet, you’ll find the most common string operations and string methods.

String operations
len(string) Returns the length of the string
for character in string Iterates over each character in the string
if substring in string Checks whether the substring is part of the string
string[i] Accesses the character at index i of the string, starting at zero
string[i:j] Accesses the substring starting at index i, ending at index j-1. If i is omitted, it's 0 by default. If j is omitted, it's len(string) by default.
String methods
string.lower() / string.upper() Returns a copy of the string with all lower / upper case characters
string.lstrip() / string.rstrip() / string.strip() Returns a copy of the string without left / right / left or right whitespace
string.count(substring) Returns the number of times substring is present in the string
string.isnumeric() Returns True if there are only numeric characters in the string. If not, returns False.
string.isalpha() Returns True if there are only alphabetic characters in the string. If not, returns False.
string.split() / string.split(delimiter) Returns a list of substrings that were separated by whitespace / delimiter
string.replace(old, new) Returns a new string where all occurrences of old have been replaced by new.
delimiter.join(list of strings) Returns a new string with all the strings joined by the delimiter



#############################################
###############################################
###############################################
#############################################


Formatting Strings Cheat Sheet
Python offers different ways to format strings. In the video, we explained the format() method. In this reading,
we'll highlight three different ways of formatting strings. For this course you only need to know the format() method.
But on the internet, you might find any of the three, so it's a good idea to know that the others exist.

Using the format() method
The format method returns a copy of the string where the {} placeholders have been
replaced with the values of the variables. These variables are converted to strings
if they weren't strings already. Empty placeholders are replaced by the variables
passed to format in the same order.



##############################################################################################

# "base string with {} placeholders".format(variables)

example = "format() method"

formatted_string = "this is an example of using the {} on a string".format(example)

print(formatted_string)

"""Outputs:
this is an example of using the format() method on a string
"""

##############################################################################################

If the placeholders indicate a number, they’re replaced by the variable corresponding to that order (starting at zero).

# "{0} {1}".format(first, second)

first = "apple"
second = "banana"
third = "carrot"

formatted_string = "{0} {2} {1}".format(first, second, third)

print(formatted_string)

"""Outputs:
apple carrot banana
"""


###############################################
#############################################
###############################################
#############################################



def get_word(sentence, n):
	# Only proceed if n is positive
	if n > 0:
		words = sentence.split()
		# Only proceed if n is not more than the number of words
		if n <= len(words):
			return words[n-1]
	return("")

print(get_word("This is a lesson about lists", 4)) # Should print: lesson
print(get_word("This is a lesson about lists", -4)) # Nothing
print(get_word("Now we are cooking!", 1)) # Should print: Now
print(get_word("Now we are cooking!", 5)) # Nothing



###############################################
#############################################


Lists Defined


Lists in Python are defined using square brackets, with the elements stored in the list
separated by commas: list = ["This", "is", "a", "list"]. You can use the len() function
to return the number of elements in a list: len(list) would return 4. You can also use
the in keyword to check if a list contains a certain element. If the element is present,
it will return a True boolean. If the element is not found in the list, it will return
False. For example, "This" in list would return True in our example. Similar to strings,
lists can also use indexing to access specific elements in a list based on their position.
You can access the first element in a list by doing list[0], which would allow you to access
the string "This".

In Python, lists and strings are quite similar. They’re both examples of sequences of data.
Sequences have similar properties, like (1) being able to iterate over them using for loops;
(2) support indexing; (3) using the len function to find the length of the sequence; (4)
using the plus operator + in order to concatenate; and (5) using the in keyword to check
if the sequence contains a value. Understanding these concepts allows you to apply them to
other sequence types as well.

###############################################
#############################################
###############################################
#############################################


Modifying Lists
While lists and strings are both sequences, a big difference between them is that lists are mutable.
This means that the contents of the list can be changed, unlike strings, which are immutable. You can
add, remove, or modify elements in a list.

You can add elements to the end of a list using the append method. You call this method on a list using
dot notation, and pass in the element to be added as a parameter. For example, list.append("New data")
would add the string "New data" to the end of the list called list.

If you want to add an element to a list in a specific position, you can use the method insert. The
method takes two parameters: the first specifies the index in the list, and the second is the element
to be added to the list. So list.insert(0, "New data") would add the string "New data" to the front of
the list. This wouldn't overwrite the existing element at the start of the list. It would just shift
all the other elements by one. If you specify an index that’s larger than the length of the list, the
element will simply be added to the end of the list.

You can remove elements from the list using the remove method. This method takes an element as a
parameter, and removes the first occurrence of the element. If the element isn’t found in the list,
you’ll get a ValueError error explaining that the element was not found in the list.

You can also remove elements from a list using the pop method. This method differs from the remove
method in that it takes an index as a parameter, and returns the element that was removed. This can
be useful if you don't know what the value is, but you know where it’s located. This can also be
useful when you need to access the data and also want to remove it from the list.

Finally, you can change an element in a list by using indexing to overwrite the value stored at the
specified index. For example, you can enter list[0] = "Old data" to overwrite the first element in
a list with the new string "Old data".


###############################################
#############################################


return the {n}th word from a passed sentence. For example, get_word
("This is a lesson about lists", 4) should return "lesson", which
is the 4th word in this sentence. Hint: remember that list indexes
start at 0, not 1.



def get_word(sentence, n):
	# Only proceed if n is positive
	if n > 0:
		words = sentence.split()
		# Only proceed if n is not more than the number of words
		if n <= len(words):
			return words[n-1]
	return("")

print(get_word("This is a lesson about lists", 4)) # Should print: lesson
print(get_word("This is a lesson about lists", -4)) # Nothing
print(get_word("Now we are cooking!", 1)) # Should print: Now
print(get_word("Now we are cooking!", 5)) # Nothing





###############################################
#############################################
###############################################
#############################################




Return a list containing everyother element in the list using a for loop




def skip_elements(elements):
	# Initialize variables
	new_list = []
	i = 0

	# Iterate through the list
	for i in range(len(elements)):
		# Does this element belong in the resulting list?
		if i%2 == 0:
			# Add this element to the resulting list
			new_list.append(elements[i])



	return new_list

print(skip_elements(["a", "b", "c", "d", "e", "f", "g"])) # Should be ['a', 'c', 'e', 'g']
print(skip_elements(['Orange', 'Pineapple', 'Strawberry', 'Kiwi', 'Peach'])) # Should be ['Orange', 'Strawberry', 'Peach']
print(skip_elements([])) # Should be []




or




def skip_elements(elements):
	# Initialize variables
	new_list = []
	i = 0

	# Iterate through the list
	for i, word in enumerate(elements):
		# Does this element belong in the resulting list?
		if i%2 == 0:
			# Add this element to the resulting list
			new_list.append(word)



	return new_list

print(skip_elements(["a", "b", "c", "d", "e", "f", "g"])) # Should be ['a', 'c', 'e', 'g']
print(skip_elements(['Orange', 'Pineapple', 'Strawberry', 'Kiwi', 'Peach'])) # Should be ['Orange', 'Strawberry', 'Peach']
print(skip_elements([])) # Should be []






###############################################
#############################################
###############################################
#############################################


USING TUPLES TO STORE INFO ABOUT A FILE

def file_size(file_info):
	name, type, file_size= file_info
	return("{:.2f}".format(file_size / 1024))

print(file_size(('Class Assignment', 'docx', 17875))) # Should print 17.46
print(file_size(('Notes', 'txt', 496))) # Should print 0.48
print(file_size(('Program', 'py', 1239))) # Should print 1.21



###############################################
#############################################




LIST COMPREHENSIONS



###############################################
#############################################




create a list with multiples of 7 from 7 to 70



multiples = []
for x in range(1, 11):
	multiples.append(x*7)

print(multiples)




With python provided list comprehension we can re write this to just take 2 lines



multiples = [ x * 7 for x in range(1, 11)]
print(multiples)




LIST comprehensions let us create new lists based on sequences or ranges

###############################################
#############################################



So as in the example above when we want to create a list based on  range or based
on the contents of a list a tuple a string or any other python sequence.





Say we have a list of strings with the names of programming
languages like this one, and we want to generate a list
of the length of the strings.

We could iterate over the list and add them using append like we did before

or we could use list comprehension like this




languages = ["Python", "Perl", "Ruby", "Go", "Java", "C"]
lengths = [len(language) for language in languages]

print(lengths)






#############################################
###############################################
###############################################
############################################


Say we wanted all the numbers that
are divisible by 3 between 0 and a 100,
we could create a list like this


z = [x for x in range (0, 101) if x % 3 == 0]
print(z)

In this case we just want the element x
to be a part of the list, but we only
want the numbers where the remainder
of the division by 3 is 0. So we add
the conditional clause after the rang


#############################################
###############################################
###############################################
#############################################


returns a list of odd numbers between 1 and n

def odd_numbers(n):
	return [x for x in range(0, n+1) if x % 2 != 0]

	#we have to add 1 to n to get to 5 since it wont display the last number

print(odd_numbers(5))  # Should print [1, 3, 5]
print(odd_numbers(10)) # Should print [1, 3, 5, 7, 9]
print(odd_numbers(11)) # Should print [1, 3, 5, 7, 9, 11]
print(odd_numbers(1))  # Should print [1]
print(odd_numbers(-1)) # Should print []



#############################################
###############################################
###############################################
#############################################




Lists and Tuples Operations Cheat Sheet
Lists and tuples are both sequences, so they share a number of sequence operations.
But, because lists are mutable, there are also a number of methods specific just to
lists. This cheat sheet gives you a run down of the common operations first, and the
list-specific operations second.

Common sequence operations
len(sequence) Returns the length of the sequence
for element in sequence Iterates over each element in the sequence
if element in sequence Checks whether the element is part of the sequence
sequence[i] Accesses the element at index i of the sequence, starting at zero
sequence[i:j] Accesses a slice starting at index i, ending at index j-1. If i is
omitted, it's 0 by default. If j is omitted, it's len(sequence) by default.
for index, element in enumerate(sequence) Iterates over both the indexes
and the elements in the sequence at the same time

 Check out the official documentation for sequence operations.
 https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range

List-specific operations and methods
list[i] = x Replaces the element at index i with x
list.append(x) Inserts x at the end of the list
list.insert(i, x) Inserts x at index i
list.pop(i) Returns the element a index i, also removing it from the list. If i is
omitted, the last element is returned and removed.
list.remove(x) Removes the first occurrence of x in the list
list.sort() Sorts the items in the list
list.reverse() Reverses the order of items of the list
list.clear() Removes all the items of the list
list.copy() Creates a copy of the list
list.extend(other_list) Appends all the elements of other_list at the end of list
 Most of these methods come from the fact that lists are mutable sequences. For more info,
 see the official documentation for mutable sequences and the list specific documentation.

List comprehension
[expression for variable in sequence] Creates a new list based on the given sequence. Each
element is the result of the given expression.
[expression for variable in sequence if condition] Creates a new list based on the given
sequence. Each element is the result of the given expression; elements only get added if
the condition is true.



#############################################
###############################################
###############################################
############################################

Rename all the files with extension hpp to the extension h


filenames = ["program.c", "stdio.hpp", "sample.hpp", "a.out", "math.hpp", "hpp.out"]
# Generate newfilenames as a list containing the new filenames
# using as many lines of code as your chosen method requires.
newfilenames = [i.replace('.hpp','.h') for i in filenames]


print(newfilenames)
# Should be ["program.c", "stdio.h", "sample.h", "a.out", "math.h", "hpp.out"]







#############################################
###############################################
###############################################
############################################


Create a function that turns text into pig latin:
a simple text transformation that modifies each word
moving the first character to the end and appending "ay"
to the end. For example, python ends up as ythonpay.


def pig_latin(text):
  say = ""
  # Separate the text into words
  new= []
  words = text.split()
  for word in words:
    # Create the pig latin word and add it to the list
    new.append(word[1:] + word[0] + "ay")
    # Turn the list back into a phrase
    phrase = " ".join(new)
  return phrase

print(pig_latin("hello how are you")) # Should be "ellohay owhay reaay ouyay"
print(pig_latin("programming in python is fun")) # Should be "rogrammingpay niay ythonpay siay unfay"


#############################################
###############################################
###############################################
############################################

The permissions of a file in a Linux system are split into three sets of
three permissions: read, write, and execute for the owner, group, and others.
Each of the three values can be expressed as an octal number summing each
permission, with 4 corresponding to read, 2 to write, and 1 to execute. Or
it can be written with a string using the letters r, w, and x or - when the
permission is not granted.

For example:
640 is read/write for the owner, read for the group, and no permissions for the others; converted to a string, it would be: "rw-r-----"
755 is read/write/execute for the owner, and read/execute for group and others; converted to a string, it would be: "rwxr-xr-x"
Fill in the blanks to make the code convert a permission in octal format into a string format.


def octal_to_string(octal):
    result = ""
    value_letters = [(4,"r"),(2,"w"),(1,"x")]
    # Iterate over each of the digits in octal
    for i in [int(n) for n in str(octal)]:
        # Check for each of the permissions values
        for value, letter in value_letters:
            if i >= value:
                result += letter
                i -= value
            else:
                result += "-"
    return result

print(octal_to_string(755)) # Should be rwxr-xr-x
print(octal_to_string(644)) # Should be rw-r--r--
print(octal_to_string(750)) # Should be rwxr-x---
print(octal_to_string(600)) # Should be rw-------

#############################################
###############################################
###############################################
############################################


The group_list function accepts a group name and a list of members,
and returns a string with the format: group_name: member1, member2,
… For example, group_list("g", ["a","b","c"]) returns "g: a, b, c".
Fill in the gaps in this function to do that.


def group_list(group, users):
  members = group + ": " + ", ".join(users)
  return members

print(group_list("Marketing", ["Mike", "Karen", "Jake", "Tasha"])) # Should be "Marketing: Mike, Karen, Jake, Tasha"
print(group_list("Engineering", ["Kim", "Jay", "Tom"])) # Should be "Engineering: Kim, Jay, Tom"
print(group_list("Users", "")) # Should be "Users:"


#############################################
###############################################
###############################################
############################################

The guest_list function reads in a list of tuples with the name, age, and profession of each party guest,
and prints the sentence "Guest is X years old and works as __." for each one. For example,
guest_list(('Ken', 30, "Chef"), ("Pat", 35, 'Lawyer'), ('Amanda', 25, "Engineer"))
should print out:

Ken is 30 years old and works as Chef.
Pat is 35 years old and works as Lawyer.
Amanda is 25 years old and works as Engineer.

Fill in the gaps in this function to do that.

def guest_list(guests):
	for name, age, profession in guests:

		print("{} is {} years old and works as {}".format(name, age, profession))


guest_list([('Ken', 30, "Chef"), ("Pat", 35, 'Lawyer'), ('Amanda', 25, "Engineer")])

#Click Run to submit code
"""
Output should match:
Ken is 30 years old and works as Chef
Pat is 35 years old and works as Lawyer
Amanda is 25 years old and works as Engineer
"""



#############################################
###############################################
###############################################
############################################


DICTIONARIES!:::::::::::::::::::::::::::

file_counts = {"jpg":10, "txt":14, "csv":2, "py":23}
print(file_counts)


file_counts["txt"]
14

"jpg" in file_counts
TRUE

"html" in file_counts
FALSE



file_counts["cfg"] = 8
print(file_counts)


file_counts["csv"] = 17
print(file_counts)


del file_counts["cfg"]
print(file_counts)

#############################################
###############################################
###############################################
############################################

The "toc" dictionary represents the table of contents for a book.
Fill in the blanks to do the following:

1) Add an entry for Epilogue on page 39.
2) Change the page number for Chapter 3 to 24.
3) Display the new dictionary contents.
4) Display True if there is Chapter 5, False if there isn't.

toc = {"Introduction":1, "Chapter 1":4, "Chapter 2":11, "Chapter 3":25, "Chapter 4":30}
toc["Epilogue"] = 39 # Epilogue starts on page 39
toc["Chapter 3"] = 24 # Chapter 3 now starts on page 24
print(toc) # What are the current contents of the dictionary?
print("Chapter 5" in toc) # Is there a Chapter 5?


#############################################
###############################################
###############################################
############################################

Dictionaries Defined
Dictionaries are another data structure in Python. They’re similar to a list in that they can be
used to organize data into collections. However, data in a dictionary isn't accessed based on
its position. Data in a dictionary is organized into pairs of keys and values. You use the key
to access the corresponding value. Where a list index is always a number, a dictionary key can
be a different data type, like a string, integer, float, or even tuples.

When creating a dictionary, you use curly brackets: {}. When storing values in a dictionary, the
key is specified first, followed by the corresponding value, separated by a colon. For example,
animals = { "bears":10, "lions":1, "tigers":2 } creates a dictionary with three key value pairs,
stored in the variable animals. The key "bears" points to the integer value 10, while the key
"lions" points to the integer value 1, and "tigers" points to the integer 2. You can access the
values by referencing the key, like this: animals["bears"]. This would return the integer 10,
since that’s the corresponding value for this key.

You can also check if a key is contained in a dictionary using the in keyword. Just like other
uses of this keyword, it will return True if the key is found in the dictionary; otherwise it
will return False.

Dictionaries are mutable, meaning they can be modified by adding, removing, and replacing elements
in a dictionary, similar to lists. You can add a new key value pair to a dictionary by assigning a
value to the key, like this: animals["zebras"] = 2. This creates the new key in the animal
dictionary called zebras, and stores the value 2. You can modify the value of an existing key by
doing the same thing. So animals["bears"] = 11 would change the value stored in the bears key from
10 to 11. Lastly, you can remove elements from a dictionary by using the del keyword. By doing del
animals["lions"] you would remove the key value pair from the animals dictionary.



#############################################
###############################################
###############################################
############################################



file_counts = {"jpg": 10, "txt": 14, "csv": 2, "py": 23}
for extension in file_counts:
	print(extension)

...
...
jpg
txt
csv
py

for ext, amount in file_counts.items():
	print("There are {} files with the .{} extension".format(amount, ext))





#############################################
###############################################
###############################################
############################################


file_counts.keys()




#############################################
###############################################
###############################################
############################################


cool_beasts = {"octopuses":"tentacles", "dolphins":"fins", "rhinos":"horns"}
for beast, parts in cool_beasts.items():
    print("{} have {}".format(beast, parts))


#############################################
###############################################
###############################################
############################################


	wardrobe = {"shirt":["red","blue","white"], "jeans":["blue","black"]}
for article, color in wardrobe.items():
    for colorlay in color:
		    print("{} {}".format(colorlay, article))



#############################################
###############################################
###############################################
#########################################################################################
###############################################
###############################################
############################################


Dictionary Methods Cheat Sheet
Dictionary Methods Cheat Sheet
Definition

x = {key1:value1, key2:value2}

Operations

len(dictionary) - Returns the number of items in the dictionary

for key in dictionary - Iterates over each key in the dictionary

for key, value in dictionary.items() - Iterates over each key,value pair in the dictionary

if key in dictionary - Checks whether the key is in the dictionary

dictionary[key] - Accesses the item with key key of the dictionary

dictionary[key] = value - Sets the value associated with key

del dictionary[key] - Removes the item with key key from the dictionary

#########################################################################################

Methods

dict.get(key, default) - Returns the element corresponding to key, or default if it's not present
dict.keys() - Returns a sequence containing the keys in the dictionary
dict.values() - Returns a sequence containing the values in the dictionary
dict.update(other_dictionary) - Updates the dictionary with the items coming from the other dictionary. Existing entries will be replaced; new entries will be added.
dict.clear() - Removes all the items of the dictionary
Check out the official documentation for dictionary operations and methods.


#############################################
###############################################
###############################################
#########################################################################################
###############################################
###############################################
############################################

a = dict(one=1, two=2, three=3)
b = {'one': 1, 'two': 2, 'three': 3}
c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))
d = dict([('two', 2), ('one', 1), ('three', 3)])
e = dict({'three': 3, 'one': 1, 'two': 2})
f = dict({'one': 1, 'three': 3}, two=2)
a == b == c == d == e == f
True

#############################################
###############################################
###############################################
#########################################################################################
MODULE 4 ASSESMENT ON Strings

The format_address function separates out parts of the address string
into new strings: house_number and street_name,
and returns: "house number X on street named Y".

The format of the input string is: numeric house number,
followed by the street name which may contain numbers,
but never by themselves, and could be several words long.

For example, "123 Main Street", "1001 1st Ave", or "55 North Center Drive". Fill in the gaps to complete this function.



def format_address(address_string):
# Declare variables
    address= ""
    number = ""
# Separate the address string into parts
  addy = address_string.split()
# Traverse through the address parts
    for i in addy:

  # Determine if the address part is the
  # house number or part of the street name
    if i.isdigit():

      number= i

    else:

      address+= i
      address+= ' '

# Does anything else need to be done
# before returning the result?

# Return the formatted string
  return "house number {} on street named {}".format(number, address)

print(format_address("123 Main Street"))
# Should print: "house number 123 on street named Main Street"

print(format_address("1001 1st Ave"))
# Should print: "house number 1001 on street named 1st Ave"

print(format_address("55 North Center Drive"))
# Should print "house number 55 on street named North Center Drive"

############################################
###############################################
###############################################
############################################

The highlight_word function changes the given word in a sentence
to its upper-case version.

For example,

highlight_word("Have a nice day", "nice") returns "Have a NICE day".

Can you write this function in just one line?


###############################################



def highlight_word(sentence, word):
	return(sentence.replace(word, word.upper()))

print(highlight_word("Have a nice day", "nice"))
print(highlight_word("Shhh, don't be so loud!", "loud"))
print(highlight_word("Automating with Python is fun", "fun"))



############################################
###############################################
###############################################
############################################

A professor with two assistants, Jamie and Drew,
wants an attendance list of the students,
in the order that they arrived in the classroom.

Drew was the first one to note which students arrived,
and then Jamie took over. After the class, they each
entered their lists into the computer and emailed
them to the professor, who needs to combine them
into one, in the order of each student's arrival.
Jamie emailed a follow-up, saying that her list is
in reverse order.

Complete the steps to
combine them into one list as follows:

the contents of Drew's list, followed by Jamie's list in reverse order,
to get an accurate list of the students as they arrived.

###############################################

def combine_lists(list1, list2):
  # Generate a new list containing the elements of list2
  # Followed by the elements of list1 in reverse order
  new_list = list2

  for names in reversed(range(len(list1))):
    new_list.append(list1[names])

  return new_list

Jamies_list = ["Alice", "Cindy", "Bobby", "Jan", "Peter"]
Drews_list = ["Mike", "Carol", "Greg", "Marcia"]

print(combine_lists(Jamies_list, Drews_list))


############################################
###############################################
###############################################
############################################


Use a list comprehension to create a list of squared numbers (n*n).
The function receives the variables start and end, and returns a list
of squares of consecutive numbers between start and end inclusively.

For example, squares(2, 3) should return [4, 9].



###############################################


def squares(start, end):
	return [ (i * i) for i in range(start, end+1) ]

print(squares(2, 3)) # Should be [4, 9]
print(squares(1, 5)) # Should be [1, 4, 9, 16, 25]
print(squares(0, 10)) # Should be [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100]


############################################
###############################################
###############################################
############################################



Complete the code to iterate through the keys and values of
the car_prices dictionary, printing out some information about each one.



###############################################


def car_listing(car_prices):
  result = ""
  for car, price in car_prices.items():
    result += "{} costs {} dollars".format(car, car_prices[car]) + "\n"
  return result

print(car_listing({"Kia Soul":19000, "Lamborghini Diablo":55000, "Ford Fiesta":13000, "Toyota Prius":24000}))


############################################
###############################################
###############################################
############################################
Question 6

Taylor and Rory are hosting a party.
They sent out invitations, and each one collected responses into dictionaries,
with names of their friends and how many guests each friend is bringing.

Each dictionary is a partial list, but Rory's list has more current
information about the number of guests.

Combine both dictionaries into one, with each friend listed only
once, and the number of guests from Rory's dictionary taking precedence,
if a name is included in both dictionaries. Then print the resulting
dictionary.


###############################################

def combine_guests(guests1, guests2):
  # Combine both dictionaries into one, with each key listed
  # only once, and the value from guests1 taking precedence
  guests2.update(guests1)

  return guests2

Rorys_guests = { "Adam":2, "Brenda":3, "David":1, "Jose":3, "Charlotte":2, "Terry":1, "Robert":4}
Taylors_guests = { "David":4, "Nancy":1, "Robert":2, "Adam":1, "Samantha":3, "Chris":5}

print(combine_guests(Rorys_guests, Taylors_guests))


############################################
###############################################
###############################################
############################################

Question 7
Use a dictionary to count the frequency of letters in the input string.
Only letters should be counted, not blank spaces, numbers, or punctuation.
Upper case should be considered the same as lower case.

For example,
count_letters("This is a sentence.")
should return {'t': 2, 'h': 1, 'i': 2, 's': 3, 'a': 1, 'e': 3, 'n': 2, 'c': 1}.




def count_letters(text):
  result = {}
  text = text.lower()
  # Go through each letter in the text
  for letter in text.lower():
    # Check if the letter needs to be counted or not
    if letter.isalpha() and letter not in result:
      result[letter] = text.lower().count(letter)
    # Add or increment the value in the dictionary

  return result

print(count_letters("AaBbCc"))
# Should be {'a': 2, 'b': 2, 'c': 2}

print(count_letters("Math is fun! 2+2=4"))
# Should be {'m': 1, 'a': 1, 't': 1, 'h': 1, 'i': 1, 's': 1, 'f': 1, 'u': 1, 'n': 1}

print(count_letters("This is a sentence."))
# Should be {'t': 2, 'h': 1, 'i': 2, 's': 3, 'a': 1, 'e': 3, 'n': 2, 'c': 1}


############################################
###############################################
###############################################
############################################

Object Inheritance
In object-oriented programming, the concept of inheritance allows you to build
relationships between objects, grouping together similar concepts and reducing
code duplication. Let's create a custom Fruit class with color and flavor attributes:


class Fruit:
  def __init__(self, color, flavor):
    self.color = color
    self.flavor = flavor

We defined a Fruit class with a constructor
for color and flavor attributes.

###############################################

Next, we'll define an Apple class along with a new
Grape class, both of which we want to inherit
properties and behaviors from the Fruit class:


class Apple(Fruit):
  pass

class Grape(Fruit):
  pass

In Python, we use parentheses in the class declaration to have
the class inherit from the Fruit class. So in this example, we’re
instructing our computer that both the Apple class and
Grape class inherit from the Fruit class.

###############################################

This means that they both have the same constructor
method which sets the color and flavor attributes.

We can now create instances of our Apple and Grape classes:


granny_smith = Apple("green", "tart")
carnelian = Grape("purple", "sweet")



print(granny_smith.flavor)
tart
print(carnelian.color)
purple


Inheritance allows us to define attributes or methods
that are shared by all types of fruit without having
to define them in each fruit class individually.

###############################################

We can then also define specific attributes or methods
that are only relevant for a specific type of fruit.

Let's look at another example, this time with animals:

class Animal:
  sound = ""
  def __init__(self, name):
    self.name = name
  def speak(self):
    print("{sound} I'm {name}! {sound}".format(
      name=self.name, sound=self.sound))

class Piglet(Animal):
  sound = "Oink!"

class Cow(Animal):
  sound = "Moooo"

We defined a parent class, Animal, with two animal types inheriting
from that class: Piglet and Cow. The parent Animal class has an
ttribute to store the sound the animal makes, and the constructor
class takes the name that will be assigned to the instance when it's
created. There is also the speak method, which will print the name of
the animal along with the sound it makes.

We defined the Piglet and Cow classes,

which inherit from the Animal class,
and we set the sound attributes for each animal type


###############################################

Now, we can create instances of our Piglet and Cow classes and have them speak:

hamlet = Piglet("Hamlet")
hamlet.speak()

output: Oink! I'm Hamlet! Oink!

milky = Cow("Milky White")
milky.speak()

output: Moooo I'm Milky White! Moooo

We create instances of both the Piglet and Cow class, and set the names for our instances.
Then we call the speak method of each instance, which results in the formatted string being printed;
it includes the sound the animal type makes, along with the instance name we assigned.

############################################
###############################################
###############################################
############################################


OBJECT COMPOSITION

We talked about how inheritance creates an ancestry for
our objects. To check for this ancestry, we can use the
is a rule.

An apple is a fruit, a piglet is an animal.

They inherit the attributes and methods of their parent
class and so they allow us to reduce code duplication,
but what if you have a relationship between classes,
where one class isn't a child of the other? Sounds confusing?

Let's check out an example to get a better idea of this.

Say we have a package class that represents a software package
which could be installed on every machine on our network.
This class has a lot of information on the software,
like the name, the version, the size, and more.

We also have a repository class that represents all the packages
that we have available for installation internally. In this class,
we want to know how many packages there are and
what's the total size of all the packages.

In this case, the repository isn't a package
and the package isn't a repository.
Instead, the repository contains packages.

To model this within our code, the repository class
will have an attribute that could be a list or a dictionary,

which will contain instances of the package class.
So for this scenario, we'll make use of the code in the other classes
by calling their methods.



This is what's called composition.


############################################
###############################################
###############################################
############################################


Let's see this in action. We'll first create a repository
class that starts with an empty dictionary of packages
when it's created.

The dictionary will have the names of the packages as keys and the package objects as values.


###############################################

class Repository:
  def __init__(self):
    self.packages = {}
  def add_package(self, package):
    self.packages[package.name] = package
  def total_size(self):
    result = 0
    for package in self.packages.values():
      result += package.size
    return result

In the constructor method, we initialize the packages dictionary,
which will contain the package objects available in this repository
instance. We initialize the dictionary in the constructor to ensure
that every instance of the Repository class has its own dictionary.

We then define the add_package method, which takes a Package object
as a parameter, and then adds it to our dictionary, using the package
name attribute as the key.

Finally, we define a total_size method which computes the total size of
all packages contained in our repository. This method iterates through
the values in our repository dictionary and adds together the size attributes
from each package object contained in the dictionary, returning the total
at the end. In this example, we’re making use of Package attributes within
our Repository class. We’re also calling the values() method on our packages
dictionary instance. Composition allows us to use objects as attributes,
as well as access all their attributes and methods.


############################################
###############################################
###############################################
############################################

class Clothing:
  stock={ 'name': [],'material' :[], 'amount':[]}
  def __init__(self,name):
    material = ""
    self.name = name
  def add_item(self, name, material, amount):
    Clothing.stock['name'].append(self.name)
    Clothing.stock['material'].append(self.material)
    Clothing.stock['amount'].append(amount)
  def Stock_by_Material(self, material):
    count=0
    n=0
  for item in Clothing.stock['material']:  ## 1 was missing "material"
    if item == material:
      count += Clothing.stock['amount'][n] ## 2 was missing ".stock"
      n+=1
  return count


class shirt(Clothing):
  material="Cotton"

class pants(Clothing):
  material="Cotton"


polo = shirt("Polo")
sweatpants = pants("Sweatpants")
polo.add_item(polo.name, polo.material, 4)
sweatpants.add_item(sweatpants.name, sweatpants.material, 6)
current_stock = polo.Stock_by_Material("Cotton")
print(current_stock)



############################################
###############################################
###############################################
############################################

OOP
OBJECT ORIENTED PROGRAMMING


We've learned that in an object-oriented language like python real-world
concepts are represented by classes. We know that instances of classes are
usually called objects. That objects have attributes which are used to
store information about them and we can make objects do work by calling
their methods. We've also learned that we can access attributes and methods
using dot notation. We then dove into objects can be organized by inheritance.
And how they can be contained inside each other using composition

############################################
###############################################
###############################################
############################################
